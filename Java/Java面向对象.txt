Java继承：
    final关键字：
        final class 类名{}
        (final关键字声明类可以把类定义为不能继承的，最终类；也可用于修饰方法，该方法不能被子类重写)
    super与this关键字：
        super关键字：访问父类成员，引用当前对象的父亲
        this关键字：指向子类自己的引用
    构造器：
        子类不继承父类的构造器，只是调用；
        如果父类构造器含有参数，则必须在子类的构造器中显式的通过super关键字调用父类的构造器并配以适当的参数
    static关键字：
        声明为static的的方法不可被重写，但可以被再次声明

抽象类：
    public abstract class Employee{
        private String name;
        private String address;
        private int number;

        public abstract double computePay(); // 抽象方法，只有声明没有定义
    }
    抽象类不能被实例化，抽象类的非抽象子类才可以创建对象
    如果一个类包含抽象方法，那么类必须是抽象类
    任何子类必须重写父类的抽象方法，或者声明自身为抽象类
    构造方法，类方法（用static修饰的方法）不能声明为抽象方法


接口：
    接口不能用做实例化，没有构造方法，接口中所有方法必须是抽象方法
    接口不是被类继承，而是被类实现
    接口支持多继承

    抽象类与接口的区别：
        1.抽象类中的方法可以有方法体，就是实现方法的具体功能，接口中没有
        2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型
        3.接口中不能含有静态代码块以及静态方法（用static修饰的方法），而抽象类是可以有静态代码块和静态方法
        4.一个类只能继承一个抽象类，一个类却可以实现多个接口


枚举：
    方法：
        values(): 返回枚举中的所有的值
        ordinal(): 找到每个枚举常量的索引，类似于数组索引
        valueOf(): 返回指定字符串值的枚举常量


Java网络编程：
    （编写运行在多个设备的程序，这些设备都通过网络连接起来）
    TCP：
        一种面向连接的、可靠的、基于字节流的传输层通信协议，位于IP层之上，应用层之下，保障两个应用程序之间的可靠通信。
    UDP：
        位于OSI模型的传输层，一个无连接的协议，提供了应用程序之间要发送数据的数据报，由于UDP缺乏可靠性且属于无连接协议，容许丢失、错误、重复...
    
    Socket编程：
        套接字使用TCP提供了两台计算机之间的通信机制。客户端程序创建一个套接字，并尝试连接服务器的套接字。
        当连接建立时，服务器会创建一个Socket对象。客户端和服务器现在可以通过对Socket对象的写入和读取来进行通信。
        java.net.Scoket类代表一个套接字，并且java.net.ServerSocket类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。

        服务器实例化一个ServerSocket对象，表示通过服务器上的端口通信；
        服务器调用ServerSocket类的accept()方法，该方法将一直等待，直到客户端连接到服务器上给定的端口；
        服务器正在等待时，一个客户端实例化一个Socket对象，指定服务器名称和端口号来请求连接；
        Socket类的构造函数试图将客户端连接到指定的服务器和端口号，如果通信被建立，则在客户端创建一个Socket对象能够与服务器进行通信；
        在服务器端，accept()方法返回服务器上一个新的socket引用，该socket连接到客户端的socket；


多线程：
    一个进程包含操作系统分配的内存单元，包含一个或多个线程；
    一个线程不能独立的存在，必须是进程的一部分；
    一个进程一直运行，直到所有的非守护线程结束运行后才能结束；
    线程生命周期：
        新建状态：
            使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态，直到程序start()
        就绪状态：
            线程对象调用start()方法后，线程进入就绪状态，就绪状态的线程处于就绪队列里，等待JVM里线程调度器的调度
        运行状态：
            就绪状态的线程获取CPU资源，就可以执行run()，此时线程处于运行状态
        阻塞状态：
            线程执行sleep（睡眠）、suspend（挂起）方法后，失去占用资源，线程就进入阻塞状态
            等待阻塞、同步阻塞、其他阻塞
        死亡状态：
            运行状态的线程完成任务或者其他终止条件发生时，线程切换到终止状态
    
    创建线程三种方法：
        通过实现Runnable接口
        通过继承Thread类本身
        通过Callable和Future创建线程


